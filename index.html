
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chronicles of Nandigiri - 3D RPG</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Garamond', serif;
      background: #000;
      overflow: hidden;
    }
    
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
    
    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
    }
    
    .ui-panel {
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #FFD700;
      border-radius: 10px;
      padding: 15px;
      color: white;
      backdrop-filter: blur(5px);
    }
    
    .menu-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 3px solid #FFD700;
      border-radius: 15px;
      padding: 30px;
      text-align: center;
      min-width: 400px;
      pointer-events: auto;
    }
    
    .stats-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 250px;
    }
    
    .minimap-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 200px;
      height: 200px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #FFD700;
      border-radius: 10px;
    }
    
    .controls-panel {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    
    .chat-panel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 300px;
      height: 150px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #FFD700;
      border-radius: 10px;
      padding: 10px;
      color: white;
      overflow-y: auto;
      font-size: 12px;
    }
    
    .character-card {
      background: rgba(255, 248, 220, 0.95);
      border: 3px solid #8B4513;
      border-radius: 1rem;
      padding: 1rem;
      margin: 0.5rem;
      transition: all 0.3s ease;
      cursor: pointer;
      color: #333;
    }
    
    .character-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(255, 215, 0, 0.5);
      border-color: #FFD700;
    }
    
    .stat-bar {
      background: #4a5568;
      height: 15px;
      border-radius: 10px;
      overflow: hidden;
      margin: 5px 0;
    }
    
    .stat-fill {
      height: 100%;
      transition: width 0.3s ease;
    }
    
    .hp-fill { background: #e53e3e; }
    .mp-fill { background: #3182ce; }
    .exp-fill { background: #38a169; }
    
    .action-button {
      background: linear-gradient(45deg, #FFD700, #FFA500);
      color: #000;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    
    .action-button:hover {
      background: linear-gradient(45deg, #FFA500, #FFD700);
      transform: scale(1.05);
    }
    
    .combat-button {
      background: linear-gradient(45deg, #DC143C, #8B0000);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 6px;
      cursor: pointer;
      margin: 5px;
      transition: all 0.3s ease;
    }
    
    .combat-button:hover {
      background: linear-gradient(45deg, #8B0000, #DC143C);
      transform: scale(1.05);
    }
    
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid #FFD700;
      border-radius: 50%;
      pointer-events: none;
      z-index: 15;
    }
    
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <!-- 3D Canvas -->
  <canvas id="gameCanvas"></canvas>
  
  <!-- Crosshair -->
  <div id="crosshair"></div>
  
  <!-- UI Overlay -->
  <div id="ui-overlay">
    <!-- Main Menu -->
    <div id="mainMenu" class="menu-panel">
      <h1 class="text-4xl font-bold text-yellow-400 mb-6">Chronicles of Nandigiri</h1>
      <h2 class="text-xl text-white mb-6">3D Fantasy RPG</h2>
      <div class="space-y-4">
        <button onclick="startSinglePlayer()" class="action-button w-full">Single Player</button>
        <button onclick="showMultiplayerMenu()" class="action-button w-full">Multiplayer</button>
      </div>
    </div>
    
    <!-- Multiplayer Menu -->
    <div id="multiplayerMenu" class="menu-panel hidden">
      <h2 class="text-2xl font-bold text-yellow-400 mb-4">Multiplayer</h2>
      <div class="space-y-4">
        <button onclick="createRoom()" class="action-button w-full">Create Room</button>
        <div>
          <input type="text" id="roomIdInput" placeholder="Enter Room ID" 
                 class="w-full px-3 py-2 border rounded mb-2 text-black">
          <button onclick="joinRoom()" class="action-button w-full">Join Room</button>
        </div>
        <button onclick="backToMainMenu()" class="bg-gray-600 text-white px-4 py-2 rounded w-full">Back</button>
      </div>
    </div>
    
    <!-- Character Selection -->
    <div id="characterSelect" class="menu-panel hidden">
      <h2 class="text-2xl font-bold text-yellow-400 mb-4">Choose Your Character</h2>
      <div id="characterGrid" class="grid grid-cols-2 gap-4 max-h-96 overflow-y-auto"></div>
    </div>
    
    <!-- Game UI -->
    <div id="gameUI" class="hidden">
      <!-- Player Stats -->
      <div class="stats-panel ui-panel">
        <h3 class="font-bold text-yellow-400 mb-2" id="playerName">Character</h3>
        <div class="text-sm">
          <div class="flex justify-between">
            <span>HP:</span>
            <span id="hpText">100/100</span>
          </div>
          <div class="stat-bar">
            <div class="stat-fill hp-fill" id="hpBar" style="width: 100%"></div>
          </div>
          
          <div class="flex justify-between">
            <span>MP:</span>
            <span id="mpText">50/50</span>
          </div>
          <div class="stat-bar">
            <div class="stat-fill mp-fill" id="mpBar" style="width: 100%"></div>
          </div>
          
          <div class="flex justify-between">
            <span>Level:</span>
            <span id="levelText">1</span>
          </div>
          <div class="flex justify-between">
            <span>Gold:</span>
            <span id="goldText" class="text-yellow-400">100</span>
          </div>
        </div>
      </div>
      
      <!-- Minimap -->
      <div class="minimap-panel ui-panel">
        <canvas id="minimapCanvas" width="180" height="180"></canvas>
      </div>
      
      <!-- Controls -->
      <div class="controls-panel">
        <button onclick="explore()" class="action-button">Explore (E)</button>
        <button onclick="rest()" class="action-button">Rest (R)</button>
        <button onclick="openInventory()" class="action-button">Inventory (I)</button>
        <button onclick="toggleMap()" class="action-button">Map (M)</button>
      </div>
      
      <!-- Chat Panel -->
      <div class="chat-panel" id="chatPanel">
        <div id="chatMessages"></div>
        <input type="text" id="chatInput" placeholder="Type a message..." 
               class="w-full mt-2 px-2 py-1 text-black rounded" 
               onkeypress="handleChatInput(event)">
      </div>
    </div>
    
    <!-- Combat UI -->
    <div id="combatUI" class="hidden">
      <div class="menu-panel">
        <h3 class="text-xl font-bold text-red-400 mb-4">Combat!</h3>
        <div id="enemyInfo" class="mb-4">
          <div class="font-bold" id="enemyName">Enemy</div>
          <div class="flex justify-between">
            <span>HP:</span>
            <span id="enemyHp">100/100</span>
          </div>
          <div class="stat-bar">
            <div class="stat-fill hp-fill" id="enemyHpBar" style="width: 100%"></div>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <button onclick="attack()" class="combat-button">Attack</button>
          <button onclick="useSkill()" class="combat-button">Use Skill</button>
          <button onclick="useItem()" class="combat-button">Use Item</button>
          <button onclick="flee()" class="combat-button">Flee</button>
        </div>
      </div>
    </div>
    
    <!-- Inventory Modal -->
    <div id="inventoryModal" class="hidden">
      <div class="menu-panel">
        <h3 class="text-xl font-bold text-yellow-400 mb-4">Inventory</h3>
        <div id="inventoryGrid" class="grid grid-cols-4 gap-2 mb-4"></div>
        <button onclick="closeInventory()" class="action-button w-full">Close</button>
      </div>
    </div>
  </div>
  
  <script src="/socket.io/socket.io.js"></script>
  <script src="characters.js"></script>
  <script>
    // 3D Scene Setup
    let scene, camera, renderer, controls;
    let player, players = {};
    let world = {};
    let gameState = {
      mode: 'menu', // menu, playing, combat
      player: null,
      location: 'Village',
      inCombat: false,
      currentEnemy: null
    };
    
    // Multiplayer
    let socket = null;
    let isMultiplayer = false;
    let currentRoom = null;
    
    // Input handling
    const keys = {};
    let mouseX = 0, mouseY = 0;
    
    function initializeGame() {
      setupScene();
      setupControls();
      createWorld();
      animate();
      
      // Show main menu
      showMainMenu();
    }
    
    function setupScene() {
      // Scene
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
      
      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 10, 20);
      
      // Renderer
      const canvas = document.getElementById('gameCanvas');
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);
      
      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI / 2.2;
      controls.minDistance = 5;
      controls.maxDistance = 50;
    }
    
    function setupControls() {
      document.addEventListener('keydown', (event) => {
        keys[event.code] = true;
        handleKeyPress(event);
      });
      
      document.addEventListener('keyup', (event) => {
        keys[event.code] = false;
      });
      
      document.addEventListener('mousemove', (event) => {
        mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
      });
      
      window.addEventListener('resize', onWindowResize);
    }
    
    function createWorld() {
      // Ground
      const groundGeometry = new THREE.PlaneGeometry(200, 200);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Village buildings
      createBuildings();
      
      // Trees
      createTrees();
      
      // Mountains in background
      createMountains();
      
      // Sky
      const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
      const skyMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x87CEEB, 
        side: THREE.BackSide 
      });
      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      scene.add(sky);
    }
    
    function createBuildings() {
      // Village inn
      const innGeometry = new THREE.BoxGeometry(8, 6, 10);
      const innMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const inn = new THREE.Mesh(innGeometry, innMaterial);
      inn.position.set(-15, 3, -10);
      inn.castShadow = true;
      scene.add(inn);
      
      // Inn roof
      const roofGeometry = new THREE.ConeGeometry(7, 3, 4);
      const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.set(-15, 7.5, -10);
      roof.rotation.y = Math.PI / 4;
      scene.add(roof);
      
      // Shop
      const shopGeometry = new THREE.BoxGeometry(6, 5, 8);
      const shopMaterial = new THREE.MeshLambertMaterial({ color: 0xDEB887 });
      const shop = new THREE.Mesh(shopGeometry, shopMaterial);
      shop.position.set(15, 2.5, -15);
      shop.castShadow = true;
      scene.add(shop);
      
      // Houses
      for (let i = 0; i < 5; i++) {
        const houseGeometry = new THREE.BoxGeometry(4, 4, 6);
        const houseMaterial = new THREE.MeshLambertMaterial({ 
          color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.1, 0.5, 0.6) 
        });
        const house = new THREE.Mesh(houseGeometry, houseMaterial);
        house.position.set(
          (Math.random() - 0.5) * 60,
          2,
          (Math.random() - 0.5) * 60
        );
        house.castShadow = true;
        scene.add(house);
      }
    }
    
    function createTrees() {
      for (let i = 0; i < 30; i++) {
        // Tree trunk
        const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 6);
        const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        
        // Tree leaves
        const leavesGeometry = new THREE.SphereGeometry(3, 8, 6);
        const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.y = 5;
        
        const tree = new THREE.Group();
        tree.add(trunk);
        tree.add(leaves);
        
        tree.position.set(
          (Math.random() - 0.5) * 180,
          3,
          (Math.random() - 0.5) * 180
        );
        
        trunk.castShadow = true;
        leaves.castShadow = true;
        scene.add(tree);
      }
    }
    
    function createMountains() {
      for (let i = 0; i < 8; i++) {
        const mountainGeometry = new THREE.ConeGeometry(
          Math.random() * 15 + 10,
          Math.random() * 20 + 20,
          8
        );
        const mountainMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
        const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
        
        const angle = (i / 8) * Math.PI * 2;
        mountain.position.set(
          Math.cos(angle) * 150,
          10,
          Math.sin(angle) * 150
        );
        
        scene.add(mountain);
      }
    }
    
    function createPlayer(characterData) {
      // Player model (simple for now)
      const playerGeometry = new THREE.CapsuleGeometry(1, 2);
      const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
      player = new THREE.Mesh(playerGeometry, playerMaterial);
      player.position.set(0, 2, 0);
      player.castShadow = true;
      scene.add(player);
      
      // Camera follow
      controls.target.copy(player.position);
      camera.position.set(player.position.x, player.position.y + 10, player.position.z + 20);
    }
    
    function updatePlayer() {
      if (!player || gameState.mode !== 'playing') return;
      
      const moveSpeed = 0.2;
      const moveVector = new THREE.Vector3();
      
      if (keys['KeyW'] || keys['ArrowUp']) moveVector.z -= moveSpeed;
      if (keys['KeyS'] || keys['ArrowDown']) moveVector.z += moveSpeed;
      if (keys['KeyA'] || keys['ArrowLeft']) moveVector.x -= moveSpeed;
      if (keys['KeyD'] || keys['ArrowRight']) moveVector.x += moveSpeed;
      
      if (moveVector.length() > 0) {
        player.position.add(moveVector);
        controls.target.copy(player.position);
        
        // Broadcast position to other players
        if (isMultiplayer && socket) {
          socket.emit('player-move', {
            position: player.position,
            rotation: player.rotation
          });
        }
      }
    }
    
    function handleKeyPress(event) {
      if (gameState.mode !== 'playing') return;
      
      switch(event.code) {
        case 'KeyE':
          explore();
          break;
        case 'KeyR':
          rest();
          break;
        case 'KeyI':
          openInventory();
          break;
        case 'KeyM':
          toggleMap();
          break;
        case 'Space':
          event.preventDefault();
          jump();
          break;
      }
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      updatePlayer();
      controls.update();
      
      renderer.render(scene, camera);
      updateMinimap();
    }
    
    function updateMinimap() {
      const canvas = document.getElementById('minimapCanvas');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#2a4d3a';
      ctx.fillRect(0, 0, 180, 180);
      
      // Draw player
      if (player) {
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.arc(90 + player.position.x, 90 + player.position.z, 3, 0, 2 * Math.PI);
        ctx.fill();
      }
      
      // Draw other players
      Object.values(players).forEach(otherPlayer => {
        ctx.fillStyle = '#FF6B6B';
        ctx.beginPath();
        ctx.arc(90 + otherPlayer.position.x, 90 + otherPlayer.position.z, 2, 0, 2 * Math.PI);
        ctx.fill();
      });
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // UI Functions
    function showMainMenu() {
      hideAllPanels();
      document.getElementById('mainMenu').classList.remove('hidden');
      gameState.mode = 'menu';
    }
    
    function showMultiplayerMenu() {
      hideAllPanels();
      document.getElementById('multiplayerMenu').classList.remove('hidden');
    }
    
    function backToMainMenu() {
      showMainMenu();
    }
    
    function showCharacterSelect() {
      hideAllPanels();
      document.getElementById('characterSelect').classList.remove('hidden');
      loadCharacterGrid();
    }
    
    function showGameUI() {
      hideAllPanels();
      document.getElementById('gameUI').classList.remove('hidden');
      gameState.mode = 'playing';
    }
    
    function hideAllPanels() {
      const panels = ['mainMenu', 'multiplayerMenu', 'characterSelect', 'gameUI', 'combatUI', 'inventoryModal'];
      panels.forEach(id => {
        document.getElementById(id).classList.add('hidden');
      });
    }
    
    function startSinglePlayer() {
      isMultiplayer = false;
      showCharacterSelect();
    }
    
    function loadCharacterGrid() {
      const grid = document.getElementById('characterGrid');
      grid.innerHTML = '';
      
      Object.entries(characterDatabase).forEach(([name, character]) => {
        const card = document.createElement('div');
        card.className = 'character-card';
        card.onclick = () => selectCharacter(name);
        
        card.innerHTML = `
          <div class="font-bold text-lg">${character.name}</div>
          <div class="text-sm text-yellow-800 font-semibold">${character.class}</div>
          <div class="text-xs mt-2">${character.description}</div>
          <div class="text-xs mt-2">
            <div>HP: ${character.maxHp} | MP: ${character.maxMp}</div>
            <div>ATK: ${character.attack} | DEF: ${character.defense}</div>
          </div>
        `;
        
        grid.appendChild(card);
      });
    }
    
    function selectCharacter(name) {
      gameState.player = { ...characterDatabase[name] };
      createPlayer(gameState.player);
      showGameUI();
      updatePlayerDisplay();
      addChatMessage('System', `Welcome ${gameState.player.name}! Use WASD to move, E to explore.`);
    }
    
    function updatePlayerDisplay() {
      if (!gameState.player) return;
      
      const player = gameState.player;
      document.getElementById('playerName').textContent = `${player.name} (${player.class})`;
      document.getElementById('hpText').textContent = `${player.hp}/${player.maxHp}`;
      document.getElementById('mpText').textContent = `${player.mp}/${player.maxMp}`;
      document.getElementById('levelText').textContent = player.level;
      document.getElementById('goldText').textContent = player.gold;
      
      // Update bars
      document.getElementById('hpBar').style.width = `${(player.hp / player.maxHp) * 100}%`;
      document.getElementById('mpBar').style.width = `${(player.mp / player.maxMp) * 100}%`;
    }
    
    // Game Actions
    function explore() {
      if (Math.random() < 0.3) {
        startCombat();
      } else if (Math.random() < 0.6) {
        const gold = Math.floor(Math.random() * 25) + 5;
        gameState.player.gold += gold;
        updatePlayerDisplay();
        addChatMessage('System', `You found ${gold} gold!`);
      } else {
        addChatMessage('System', 'You explore the area but find nothing interesting.');
      }
    }
    
    function rest() {
      if (gameState.player.gold >= 10) {
        gameState.player.hp = gameState.player.maxHp;
        gameState.player.mp = gameState.player.maxMp;
        gameState.player.gold -= 10;
        updatePlayerDisplay();
        addChatMessage('System', 'You rest and recover all HP and MP! (-10 gold)');
      } else {
        addChatMessage('System', 'Not enough gold to rest! (10 gold needed)');
      }
    }
    
    function jump() {
      if (!player) return;
      
      // Simple jump animation
      const originalY = player.position.y;
      const jumpHeight = 4;
      const jumpDuration = 500;
      
      let startTime = null;
      
      function animateJump(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        const progress = elapsed / jumpDuration;
        
        if (progress < 1) {
          const height = originalY + jumpHeight * Math.sin(progress * Math.PI);
          player.position.y = height;
          requestAnimationFrame(animateJump);
        } else {
          player.position.y = originalY;
        }
      }
      
      requestAnimationFrame(animateJump);
    }
    
    function startCombat() {
      gameState.inCombat = true;
      gameState.mode = 'combat';
      
      const enemies = ['Goblin', 'Orc', 'Skeleton'];
      const enemyType = enemies[Math.floor(Math.random() * enemies.length)];
      
      gameState.currentEnemy = {
        name: enemyType,
        hp: 50,
        maxHp: 50,
        attack: 12,
        defense: 5
      };
      
      hideAllPanels();
      document.getElementById('combatUI').classList.remove('hidden');
      updateEnemyDisplay();
      addChatMessage('System', `A ${enemyType} appears! Prepare for battle!`);
    }
    
    function updateEnemyDisplay() {
      const enemy = gameState.currentEnemy;
      document.getElementById('enemyName').textContent = enemy.name;
      document.getElementById('enemyHp').textContent = `${enemy.hp}/${enemy.maxHp}`;
      document.getElementById('enemyHpBar').style.width = `${(enemy.hp / enemy.maxHp) * 100}%`;
    }
    
    function attack() {
      if (!gameState.inCombat) return;
      
      const player = gameState.player;
      const enemy = gameState.currentEnemy;
      
      const damage = Math.max(1, player.attack - enemy.defense + Math.floor(Math.random() * 5));
      enemy.hp -= damage;
      
      addChatMessage('Combat', `You attack for ${damage} damage!`);
      
      if (enemy.hp <= 0) {
        const exp = 25;
        const gold = 15;
        player.exp += exp;
        player.gold += gold;
        addChatMessage('Combat', `Victory! +${exp} EXP, +${gold} gold`);
        endCombat();
      } else {
        // Enemy attacks back
        const enemyDamage = Math.max(1, enemy.attack - player.defense + Math.floor(Math.random() * 3));
        player.hp -= enemyDamage;
        addChatMessage('Combat', `${enemy.name} attacks for ${enemyDamage} damage!`);
        
        if (player.hp <= 0) {
          player.hp = 1;
          addChatMessage('Combat', 'You were defeated but managed to escape!');
          endCombat();
        }
      }
      
      updatePlayerDisplay();
      updateEnemyDisplay();
    }
    
    function useSkill() {
      if (!gameState.inCombat || gameState.player.mp < 10) return;
      
      gameState.player.mp -= 10;
      const damage = Math.floor(Math.random() * 20) + gameState.player.attack;
      gameState.currentEnemy.hp -= damage;
      
      addChatMessage('Combat', `You use a skill for ${damage} damage!`);
      
      if (gameState.currentEnemy.hp <= 0) {
        addChatMessage('Combat', 'Victory!');
        endCombat();
      }
      
      updatePlayerDisplay();
      updateEnemyDisplay();
    }
    
    function useItem() {
      if (!gameState.inCombat) return;
      
      const healing = 30;
      gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healing);
      addChatMessage('Combat', `You use a health potion and recover ${healing} HP!`);
      updatePlayerDisplay();
    }
    
    function flee() {
      if (Math.random() < 0.7) {
        addChatMessage('Combat', 'You successfully flee from combat!');
        endCombat();
      } else {
        addChatMessage('Combat', 'Failed to escape!');
      }
    }
    
    function endCombat() {
      gameState.inCombat = false;
      gameState.currentEnemy = null;
      showGameUI();
    }
    
    function openInventory() {
      document.getElementById('inventoryModal').classList.remove('hidden');
      
      const grid = document.getElementById('inventoryGrid');
      grid.innerHTML = '';
      
      gameState.player.inventory.forEach(item => {
        const div = document.createElement('div');
        div.className = 'bg-gray-700 p-2 rounded text-white text-sm text-center';
        div.textContent = item;
        grid.appendChild(div);
      });
    }
    
    function closeInventory() {
      document.getElementById('inventoryModal').classList.add('hidden');
    }
    
    function toggleMap() {
      const minimap = document.querySelector('.minimap-panel');
      minimap.style.display = minimap.style.display === 'none' ? 'block' : 'none';
    }
    
    // Chat System
    function addChatMessage(sender, message) {
      const chatMessages = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      messageDiv.innerHTML = `<span class="text-yellow-400">[${sender}]</span> ${message}`;
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function handleChatInput(event) {
      if (event.key === 'Enter') {
        const input = event.target;
        const message = input.value.trim();
        
        if (message) {
          addChatMessage(gameState.player.name, message);
          
          if (isMultiplayer && socket) {
            socket.emit('chat-message', { message: message });
          }
          
          input.value = '';
        }
      }
    }
    
    // Multiplayer Functions
    function createRoom() {
      if (!socket) {
        socket = io();
        setupSocketEvents();
      }
      socket.emit('create-room');
    }
    
    function joinRoom() {
      const roomId = document.getElementById('roomIdInput').value.toUpperCase();
      if (roomId) {
        isMultiplayer = true;
        if (!socket) {
          socket = io();
          setupSocketEvents();
        }
        currentRoom = roomId;
        showCharacterSelect();
      }
    }
    
    function setupSocketEvents() {
      socket.on('room-created', (data) => {
        currentRoom = data.roomId;
        isMultiplayer = true;
        addChatMessage('System', `Room ${currentRoom} created! Share this ID with friends.`);
        showCharacterSelect();
      });
      
      socket.on('player-joined', (data) => {
        addChatMessage('System', `${data.playerName} joined the game!`);
      });
      
      socket.on('player-move', (data) => {
        // Update other player positions
        if (players[data.socketId]) {
          players[data.socketId].position.copy(data.position);
        }
      });
      
      socket.on('chat-message', (data) => {
        addChatMessage(data.playerName, data.message);
      });
    }
    
    // Initialize the game when page loads
    window.addEventListener('load', initializeGame);
  </script>
</body>
</html>
